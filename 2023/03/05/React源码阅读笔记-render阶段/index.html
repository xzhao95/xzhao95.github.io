<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.css">
  <script src="https://cdn.bootcdn.net/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":true,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="render阶段开始与renderRootSync或renderRootConcurrent函数，该阶段可分为两步，分别为beginWork和completeWork。是一个向下“递”“归”的过程  12345678function Demo() &amp;#123;  return &lt;div&gt;    &lt;p&gt;This is Child1&lt;&#x2F;p&gt;    &lt;span&amp;">
<meta property="og:type" content="article">
<meta property="og:title" content="React源码阅读笔记-render阶段">
<meta property="og:url" content="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/index.html">
<meta property="og:site_name" content="阿赵的烂笔头">
<meta property="og:description" content="render阶段开始与renderRootSync或renderRootConcurrent函数，该阶段可分为两步，分别为beginWork和completeWork。是一个向下“递”“归”的过程  12345678function Demo() &amp;#123;  return &lt;div&gt;    &lt;p&gt;This is Child1&lt;&#x2F;p&gt;    &lt;span&amp;">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679387172862-8d67cfca-7917-4c3f-ba1a-c2628c1dc32d.png">
<meta property="og:image" content="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679388086219-acc53559-29b2-4430-a994-72f91d2d4afe.png">
<meta property="og:image" content="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679389649433-d0e36127-6496-4141-87c3-15c7a01c064a.png">
<meta property="article:published_time" content="2023-03-05T07:37:57.000Z">
<meta property="article:modified_time" content="2023-03-24T10:46:05.664Z">
<meta property="article:author" content="赵依婷">
<meta property="article:tag" content="js">
<meta property="article:tag" content="react">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679387172862-8d67cfca-7917-4c3f-ba1a-c2628c1dc32d.png">

<link rel="canonical" href="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>React源码阅读笔记-render阶段 | 阿赵的烂笔头</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">阿赵的烂笔头</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/avatar.jpeg">
      <meta itemprop="name" content="赵依婷">
      <meta itemprop="description" content="打工都是人上人！">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="阿赵的烂笔头">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          React源码阅读笔记-render阶段
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-03-05 15:37:57" itemprop="dateCreated datePublished" datetime="2023-03-05T15:37:57+08:00">2023-03-05</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/web%E5%89%8D%E7%AB%AF/" itemprop="url" rel="index"><span itemprop="name">web前端</span></a>
                </span>
            </span>

          
            <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv" style="display: none;">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span id="busuanzi_value_page_pv"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="far fa-comment"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <p>render阶段开始与<code>renderRootSync</code>或<code>renderRootConcurrent</code>函数，该阶段可分为两步，分别为beginWork和completeWork。是一个向下“递”“归”的过程 </p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Demo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">    &lt;p&gt;This is Child1&lt;/p&gt;</span><br><span class="line">    &lt;span&gt;This is sibling&lt;/span&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">Demo</span> /&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>对应的fiber树结构如下：<br><img src="/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679387172862-8d67cfca-7917-4c3f-ba1a-c2628c1dc32d.png" alt="1679387172862-8d67cfca-7917-4c3f-ba1a-c2628c1dc32d.png"><br>代码执行后，打印结果：<img src="/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679388086219-acc53559-29b2-4430-a994-72f91d2d4afe.png" alt="1679388086219-acc53559-29b2-4430-a994-72f91d2d4afe.png"><br>输出结果解析：</p>
<ol>
<li>rootFiber进入beginWork</li>
<li>Demo进入beginWork</li>
<li>div进入beginWork</li>
<li>p进入beginWork</li>
<li>p进入completeWork</li>
<li>span进入beginWork</li>
<li>span进入completeWork</li>
<li>div进入completeWork</li>
<li>Demo进入completeWork</li>
<li>rootFiber进入completeWork<blockquote>
<p>文本节点是因为React针对单一文本节点的fiber进行特殊处理所以，没有进入beginWork和completeWork</p>
</blockquote>
</li>
</ol>
<h2 id="入口函数"><a href="#入口函数" class="headerlink" title="入口函数"></a>入口函数</h2><p>在renderRootConcurrent函数中，核心在于调用workLoopConcurrent方法，开始进行递归创建fiber树</p>
<ul>
<li>处理hook相关的dispatcher</li>
<li>创建一个workInProgress Fiber，并将RootFiber与workInProgress Fiber关联</li>
<li>调用workLoopConcurrent方法创建fiber树</li>
<li>创建结束后，弹出dispatcher</li>
<li>如果fiber树创建完成，则返回结束状态</li>
</ul>
<p><img src="/2023/03/05/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-render%E9%98%B6%E6%AE%B5/1679389649433-d0e36127-6496-4141-87c3-15c7a01c064a.png" alt="1679389649433-d0e36127-6496-4141-87c3-15c7a01c064a.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">renderRootConcurrent</span>(<span class="params">root: FiberRoot, lanes: Lanes</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO. hook相关</span></span><br><span class="line">  <span class="keyword">const</span> prevExecutionContext = executionContext;</span><br><span class="line">  executionContext |= RenderContext;</span><br><span class="line">  <span class="keyword">const</span> prevDispatcher = pushDispatcher();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mount阶段，workInProgressRoot为空</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRoot !== root || workInProgressRootRenderLanes !== lanes) &#123;</span><br><span class="line">    workInProgressTransitions = getTransitionsForLanes(root, lanes);</span><br><span class="line">    resetRenderTimer();</span><br><span class="line">    <span class="comment">// 用于创建workInProgress Fiber的rootFiber</span></span><br><span class="line">    <span class="comment">// 通过RootFiber.alternate与workInProgress Fiber关联，workInProgress Fiber.alternate也指向RootFiber</span></span><br><span class="line">    prepareFreshStack(root, lanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用try...catch包裹，处理出错的节点</span></span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      workLoopConcurrent();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (thrownValue) &#123;</span><br><span class="line">      handleError(root, thrownValue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">  resetContextDependencies();</span><br><span class="line"></span><br><span class="line">  popDispatcher(prevDispatcher);</span><br><span class="line">  executionContext = prevExecutionContext;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if the tree has completed.</span></span><br><span class="line">  <span class="comment">// 检查是否fiber树是否以遍历完成</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> RootInProgress;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Completed the tree.</span></span><br><span class="line">    <span class="comment">// Set this to null to indicate there&#x27;s no in-progress render.</span></span><br><span class="line">    workInProgressRoot = <span class="literal">null</span>;</span><br><span class="line">    workInProgressRootRenderLanes = NoLanes;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Return the final exit status.</span></span><br><span class="line">    <span class="keyword">return</span> workInProgressRootExitStatus;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>renderRootConcurrent和renderRootSync的核心区别在于，异步render阶段调用workLoopConcurrent方法，而同步render阶段调用workLoopSync方法<br>而两者的区别在于，循环中是否可以暂停任务，也就是是否可调用shouldYield方法，暂停任务</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopConcurrent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Perform work until Scheduler asks us to yield</span></span><br><span class="line">  <span class="comment">// 跟同步执行差别在于shouldYield，如果浏览器帧剩余时间不足，则暂停任务，等浏览器有空闲时间再重新执行</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span> &amp;&amp; !shouldYield()) &#123;</span><br><span class="line">    <span class="comment">// 开始render阶段的“递”“归”阶段</span></span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoopSync</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Already timed out, so perform work without checking if we need to yield.</span></span><br><span class="line">  <span class="keyword">while</span> (workInProgress !== <span class="literal">null</span>) &#123;</span><br><span class="line">    performUnitOfWork(workInProgress);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>performUnitOfWork开始进行深度遍历，workInProgress指向正在处理的fiber节点，当beginWork处理完成后，返回fiber子节点，如果next存在，则将workProgress指向子fiber，进入下一轮循环，否则执行completeWork，</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// current指向的是当前fiber节点，也就是上一次更新时创建的fiber节点</span></span><br><span class="line">  <span class="keyword">const</span> current = unitOfWork.alternate;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递阶段，也就是捕获阶段，主要使用beginWork方法</span></span><br><span class="line">  <span class="keyword">let</span> next;</span><br><span class="line">  next = beginWork(current, unitOfWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">  unitOfWork.memoizedProps = unitOfWork.pendingProps;</span><br><span class="line">  <span class="comment">// 归阶段，也就是冒泡阶段，主要使用completeUnitOfWork方法</span></span><br><span class="line">  <span class="comment">// 如果没有有子fiber则执行completeUnitOfWork，如果有，则将子fiber作为正在处理的fiber，也就是workInProgress</span></span><br><span class="line">  <span class="keyword">if</span> (next === <span class="literal">null</span>) &#123;</span><br><span class="line">    completeUnitOfWork(unitOfWork);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    workInProgress = next;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ReactCurrentOwner.current = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="“递”-beginWork"><a href="#“递”-beginWork" class="headerlink" title="“递”-beginWork"></a>“递”-beginWork</h2><p>根据fiber不同的tag进行不同的创建方法，最后都是通过调用reconcileChildren方法创建fiber子节点</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">beginWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 通过判断current判断是update阶段还是mount阶段</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// update阶段</span></span><br><span class="line">    <span class="keyword">const</span> oldProps = current.memoizedProps;</span><br><span class="line">    <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      oldProps !== newProps ||</span><br><span class="line">      hasLegacyContextChanged()</span><br><span class="line">    ) &#123;</span><br><span class="line">      didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(</span><br><span class="line">        current,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">      <span class="keyword">if</span> (</span><br><span class="line">        !hasScheduledUpdateOrContext &amp;&amp;</span><br><span class="line">        (workInProgress.flags &amp; DidCapture) === NoFlags</span><br><span class="line">      ) &#123;</span><br><span class="line">        <span class="comment">// No pending updates or context. Bail out now.</span></span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> attemptEarlyBailoutIfNoScheduledUpdate(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          renderLanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ((current.flags &amp; ForceUpdateForLegacySuspense) !== NoFlags) &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">true</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// mount阶段</span></span><br><span class="line">    didReceiveUpdate = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 设置workInProgress的优先级，设为NoLanes(最高优先级)</span></span><br><span class="line">  workInProgress.lanes = NoLanes;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据workInProgress的tag，进行不同的处理方法，创建子节点</span></span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="comment">// 不明确的组件，也就是不知道当前组件为什么类型</span></span><br><span class="line">  	<span class="comment">// mount阶段，所有函数组件和类组件都会标识为这个类型，等执行完renderWithHooks方法后，根据返回的值来判断类型，并打上对应标识</span></span><br><span class="line">    <span class="comment">// 等update阶段时，就能根据tag区分函数组件还是类组件</span></span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent: &#123;</span><br><span class="line">      <span class="keyword">return</span> mountIndeterminateComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        workInProgress.type,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 函数组件</span></span><br><span class="line">    <span class="keyword">case</span> FunctionComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateFunctionComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// class组件</span></span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">const</span> unresolvedProps = workInProgress.pendingProps;</span><br><span class="line">      <span class="keyword">const</span> resolvedProps =</span><br><span class="line">        workInProgress.elementType === Component</span><br><span class="line">          ? unresolvedProps</span><br><span class="line">          : resolveDefaultProps(Component, unresolvedProps);</span><br><span class="line">      <span class="keyword">return</span> updateClassComponent(</span><br><span class="line">        current,</span><br><span class="line">        workInProgress,</span><br><span class="line">        Component,</span><br><span class="line">        resolvedProps,</span><br><span class="line">        renderLanes,</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 对应Fiber树的根节点</span></span><br><span class="line">    <span class="keyword">case</span> HostRoot:</span><br><span class="line">      <span class="keyword">return</span> updateHostRoot(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="comment">// 原生标签组件</span></span><br><span class="line">    <span class="keyword">case</span> HostComponent:</span><br><span class="line">      <span class="keyword">return</span> updateHostComponent(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="comment">// 文本元素</span></span><br><span class="line">    <span class="keyword">case</span> HostText:</span><br><span class="line">      <span class="comment">//如果是文本类型，直接返回null</span></span><br><span class="line">      <span class="keyword">return</span> updateHostText(current, workInProgress);</span><br><span class="line">    <span class="comment">// 省略其他类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原生根节点-HostRoot"><a href="#原生根节点-HostRoot" class="headerlink" title="原生根节点-HostRoot"></a>原生根节点-HostRoot</h3><p>调用了updateHostRoot方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostRoot</span>(<span class="params">current, workInProgress, renderLanes</span>) </span>&#123;</span><br><span class="line">  pushHostRootContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&#x27;Should have a current fiber. This is a bug in React.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 状态计算，更新整合到workInProgress.memoizedState中来</span></span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> prevChildren = prevState.element;</span><br><span class="line">  cloneUpdateQueue(current, workInProgress);</span><br><span class="line">  <span class="comment">// 遍历updateQueue.shared.pending，提取足够优先级的update对象，计算出最终的状态，存放在workInProgress.memoizedState中</span></span><br><span class="line">  processUpdateQueue(workInProgress, nextProps, <span class="literal">null</span>, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> nextState: RootState = workInProgress.memoizedState;</span><br><span class="line">  <span class="keyword">const</span> root: FiberRoot = workInProgress.stateNode;</span><br><span class="line">  pushRootTransition(workInProgress, root, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取下级ReactElement对象</span></span><br><span class="line">  <span class="keyword">const</span> nextChildren = nextState.element;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果下级对象与之前的下级对象一样，则复用节点</span></span><br><span class="line">  <span class="keyword">if</span> (nextChildren === prevChildren) &#123;</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 否则，根据ReactElement对象，调用reconcileChildren方法，生成Fiber子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="comment">// 返回生成的fiber子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="不明确组件-IndeterminateComponent"><a href="#不明确组件-IndeterminateComponent" class="headerlink" title="不明确组件-IndeterminateComponent"></a>不明确组件-IndeterminateComponent</h3><ul>
<li><p>执行renderWithHooks方法，执行组件函数，根据返回的value类型以及是否value对象上是否包含render方法，来判断是类组件还是函数组件</p>
</li>
<li><p>如果是类组件，则走类组件的那几个方法，指定updater，调用componentWillMount等生命周期函数，执行render方法生成vdom，最后调用reconcileChildren，生成fiber节点，并返回子fiber</p>
</li>
<li><p>如果是函数组件，则调用reconcileChildren方法，并返回子fiber</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mountIndeterminateComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  _current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> props = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">let</span> context;</span><br><span class="line">  <span class="keyword">if</span> (!disableLegacyContext) &#123;</span><br><span class="line">    <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      <span class="literal">false</span>,</span><br><span class="line">    );</span><br><span class="line">    context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line">  <span class="keyword">let</span> value;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行组件函数，并获取执行后返回的值</span></span><br><span class="line">  <span class="comment">// 如果是函数组件，则返回vdom</span></span><br><span class="line">  <span class="comment">// 如果是类组件，则返回实例化后的组件对象，且包含render方法</span></span><br><span class="line">  value = renderWithHooks(</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    props,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  hasId = checkDidRenderIdHook();</span><br><span class="line"></span><br><span class="line">  workInProgress.flags |= PerformedWork;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    !disableModulePatternComponents &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">    value !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">    <span class="keyword">typeof</span> value.render === <span class="string">&#x27;function&#x27;</span> &amp;&amp;</span><br><span class="line">    value.$$typeof === <span class="literal">undefined</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="comment">// 如果value是个对象，且存在render方法，则此fiber是类组件</span></span><br><span class="line">    workInProgress.tag = ClassComponent;</span><br><span class="line"></span><br><span class="line">    workInProgress.memoizedState = <span class="literal">null</span>;</span><br><span class="line">    workInProgress.updateQueue = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> hasContext = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">      hasContext = <span class="literal">true</span>;</span><br><span class="line">      pushLegacyContextProvider(workInProgress);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      hasContext = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    workInProgress.memoizedState =</span><br><span class="line">      value.state !== <span class="literal">null</span> &amp;&amp; value.state !== <span class="literal">undefined</span> ? value.state : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化该fiber的updateQueue</span></span><br><span class="line">    initializeUpdateQueue(workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在该组件实例上设置classComponentUpdater，并将fiber的stateNode执行该实例对象</span></span><br><span class="line">    adoptClassInstance(workInProgress, value);</span><br><span class="line">    <span class="comment">// 进行类组件实例的一些初始化操作，如对props和state等的赋值，以及执行实例上的getDerivedStateFromProps、getSnapshotBeforeUpdate、componentWillMount方法</span></span><br><span class="line">    mountClassInstance(workInProgress, Component, props, renderLanes);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 执行实例的render方法，并通过调用reconcileChildren方法，创建子fiber节点并返回</span></span><br><span class="line">    <span class="keyword">return</span> finishClassComponent(</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      <span class="literal">true</span>,</span><br><span class="line">      hasContext,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 否则是个函数组件</span></span><br><span class="line">    workInProgress.tag = FunctionComponent;</span><br><span class="line"></span><br><span class="line">    reconcileChildren(<span class="literal">null</span>, workInProgress, value, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="原生组件-HostComponent"><a href="#原生组件-HostComponent" class="headerlink" title="原生组件-HostComponent"></a>原生组件-HostComponent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateHostComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  pushHostContext(workInProgress);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// hostComponent是原生标签组件，是无状态的，例如div、p等，所以只需要收集nextProps就可以</span></span><br><span class="line">  <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">  <span class="keyword">const</span> nextProps = workInProgress.pendingProps;</span><br><span class="line">  <span class="keyword">const</span> prevProps = current !== <span class="literal">null</span> ? current.memoizedProps : <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取下级ReactElement对象</span></span><br><span class="line">  <span class="keyword">let</span> nextChildren = nextProps.children;</span><br><span class="line">  <span class="comment">// 判断子节点是否是文本节点</span></span><br><span class="line">  <span class="keyword">const</span> isDirectTextChild = shouldSetTextContent(type, nextProps);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (isDirectTextChild) &#123;</span><br><span class="line">    <span class="comment">// 如果是文本子节点，则下一个节点为null</span></span><br><span class="line">    nextChildren = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prevProps !== <span class="literal">null</span> &amp;&amp; shouldSetTextContent(type, prevProps)) &#123;</span><br><span class="line">    <span class="comment">// 如果是update状态，且之前子节点为文本节点，则将此次更新的fiber标识为内容重置</span></span><br><span class="line">    workInProgress.flags |= ContentReset;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果有ref，则在flags上标记ref更新</span></span><br><span class="line">  markRef(current, workInProgress);</span><br><span class="line">  <span class="comment">// 根据ReactElement对象，调用reconcileChildren方法生成Fiber子节点</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="comment">// 返回生成的fiber子节点</span></span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="函数组件-FunctionComponent"><a href="#函数组件-FunctionComponent" class="headerlink" title="函数组件-FunctionComponent"></a>函数组件-FunctionComponent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> context;</span><br><span class="line">  <span class="keyword">if</span> (!disableLegacyContext) &#123;</span><br><span class="line">    <span class="keyword">const</span> unmaskedContext = getUnmaskedContext(workInProgress, Component, <span class="literal">true</span>);</span><br><span class="line">    context = getMaskedContext(workInProgress, unmaskedContext);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> nextChildren;</span><br><span class="line">  <span class="keyword">let</span> hasId;</span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 执行函数，并返回函数执行后返回的vdom，也就是ReactElement对象</span></span><br><span class="line">  nextChildren = renderWithHooks(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    nextProps,</span><br><span class="line">    context,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  hasId = checkDidRenderIdHook();</span><br><span class="line">	<span class="comment">// 从beginWork前面的判断可知，didReceiveUpdate在新props和老props相同且type也相同的情况下为false</span></span><br><span class="line">  <span class="comment">// 当update阶段，且didReceiveUpdate为false时，复用子fiber并返回</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; !didReceiveUpdate) &#123;</span><br><span class="line">    bailoutHooks(current, workInProgress, renderLanes);</span><br><span class="line">    <span class="keyword">return</span> bailoutOnAlreadyFinishedWork(current, workInProgress, renderLanes);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// React DevTools reads this flag.</span></span><br><span class="line">  workInProgress.flags |= PerformedWork;</span><br><span class="line">  <span class="comment">// 创建子fiber并返回</span></span><br><span class="line">  reconcileChildren(current, workInProgress, nextChildren, renderLanes);</span><br><span class="line">  <span class="keyword">return</span> workInProgress.child;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类组件-ClassComponent"><a href="#类组件-ClassComponent" class="headerlink" title="类组件-ClassComponent"></a>类组件-ClassComponent</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateClassComponent</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  Component: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextProps: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// context相关</span></span><br><span class="line">  <span class="keyword">let</span> hasContext;</span><br><span class="line">  <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">    hasContext = <span class="literal">true</span>;</span><br><span class="line">    pushLegacyContextProvider(workInProgress);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    hasContext = <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  prepareToReadContext(workInProgress, renderLanes);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> instance = workInProgress.stateNode;</span><br><span class="line">  <span class="keyword">let</span> shouldUpdate;</span><br><span class="line">  <span class="keyword">if</span> (instance === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果组件还没有实例化过</span></span><br><span class="line">    resetSuspendedCurrentOnMountInLegacyMode(current, workInProgress);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化类组件，并对updater进行初始化，</span></span><br><span class="line">    constructClassInstance(workInProgress, Component, nextProps);</span><br><span class="line">    <span class="comment">// 进行类组件实例的一些初始化操作，如对props和state等的赋值，以及执行实例上的getDerivedStateFromProps、getSnapshotBeforeUpdate、componentWillMount方法</span></span><br><span class="line">    mountClassInstance(workInProgress, Component, nextProps, renderLanes);</span><br><span class="line">    shouldUpdate = <span class="literal">true</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 处于mount阶段，但存在实例</span></span><br><span class="line">    shouldUpdate = resumeMountClassInstance(</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 更新实例</span></span><br><span class="line">    shouldUpdate = updateClassInstance(</span><br><span class="line">      current,</span><br><span class="line">      workInProgress,</span><br><span class="line">      Component,</span><br><span class="line">      nextProps,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 执行实例的render方法，并通过调用reconcileChildren方法，创建子fiber节点并返回</span></span><br><span class="line">  <span class="keyword">const</span> nextUnitOfWork = finishClassComponent(</span><br><span class="line">    current,</span><br><span class="line">    workInProgress,</span><br><span class="line">    Component,</span><br><span class="line">    shouldUpdate,</span><br><span class="line">    hasContext,</span><br><span class="line">    renderLanes,</span><br><span class="line">  );</span><br><span class="line">  <span class="keyword">return</span> nextUnitOfWork;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="核心函数：reconcileChildren（diff算法）"><a href="#核心函数：reconcileChildren（diff算法）" class="headerlink" title="核心函数：reconcileChildren（diff算法）"></a>核心函数：reconcileChildren（diff算法）</h3><p>该方法中，在mount阶段，会调用mountChildFibers方法，直接创建新的子Fiber节点；而在update阶段，会跟上次更新创建的fiber节点做比较，考虑是否复用组件，是一种提高性能的方式，也就是diff算法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  nextChildren: any,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (current === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 对于mount阶段，调用mountChildFibers方法，创建新的子Fiber节点</span></span><br><span class="line">    workInProgress.child = mountChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      <span class="literal">null</span>,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 对于update阶段，调用reconcileChildFibers方法，将当前组件与该组件在上次更新时创建的Fiber节点做比较，将比较结果生成新Fiber节点</span></span><br><span class="line">    workInProgress.child = reconcileChildFibers(</span><br><span class="line">      workInProgress,</span><br><span class="line">      current.child,</span><br><span class="line">      nextChildren,</span><br><span class="line">      renderLanes,</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个方法在ReactChildFiber文件中，可以看到这两个方法其实调用的是同一个方法<code>ChildReconciler</code>，只是传参不同</p>
</li>
<li><p>如果是fragments组件，则直接取该组件内的子节点作为当前组件的子节点</p>
</li>
<li><p>如果子节点是单节点，则调用reconcileSingleElement做单节点协调（单节点diff），将返回的更新后的fiber节点标记为新增节点（Placement），也就是placeSingleChild方法所做的事</p>
</li>
<li><p>如果子节点是数组，则调用reconcileChildrenArray做多节点协调（多节点diff）</p>
</li>
<li><p>如果子节点是文本，则调用reconcileSingleTextNode做文本节点协调</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ChildReconciler</span>(<span class="params">shouldTrackSideEffects</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 还包含了其他方法，此处暂时省略。。。</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">reconcileChildFibers</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">    returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">    currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">    newChild: any,</span></span></span><br><span class="line"><span class="function"><span class="params">    lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params">  </span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 处理fragments标签组件，也就是&lt;&gt;...&lt;/&gt;，将该组件的子节点作为当前组件的子节点</span></span><br><span class="line">    <span class="keyword">const</span> isUnkeyedTopLevelFragment =</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">      newChild !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">      newChild.type === REACT_FRAGMENT_TYPE &amp;&amp;</span><br><span class="line">      newChild.key === <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isUnkeyedTopLevelFragment) &#123;</span><br><span class="line">      newChild = newChild.props.children;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Handle object types</span></span><br><span class="line">    <span class="comment">// 根据子节点的类型做不同处理，diff算法</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;object&#x27;</span> &amp;&amp; newChild !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">switch</span> (newChild.$$typeof) &#123;</span><br><span class="line">        <span class="keyword">case</span> REACT_ELEMENT_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSingleElement(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_PORTAL_TYPE:</span><br><span class="line">          <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">            reconcileSinglePortal(</span><br><span class="line">              returnFiber,</span><br><span class="line">              currentFirstChild,</span><br><span class="line">              newChild,</span><br><span class="line">              lanes,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">        <span class="keyword">case</span> REACT_LAZY_TYPE:</span><br><span class="line">          <span class="keyword">const</span> payload = newChild._payload;</span><br><span class="line">          <span class="keyword">const</span> init = newChild._init;</span><br><span class="line">          <span class="comment">// <span class="doctag">TODO:</span> This function is supposed to be non-recursive.</span></span><br><span class="line">          <span class="keyword">return</span> reconcileChildFibers(</span><br><span class="line">            returnFiber,</span><br><span class="line">            currentFirstChild,</span><br><span class="line">            init(payload),</span><br><span class="line">            lanes,</span><br><span class="line">          );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (isArray(newChild)) &#123;</span><br><span class="line">        <span class="comment">// 返回新创建的子节点Fiber</span></span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenArray(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (getIteratorFn(newChild)) &#123;</span><br><span class="line">        <span class="keyword">return</span> reconcileChildrenIterator(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        );</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      throwOnInvalidObjectType(returnFiber, newChild);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果子节点是字符串类型或者是数字类型，则是文本节点</span></span><br><span class="line">    <span class="keyword">if</span> (</span><br><span class="line">      (<span class="keyword">typeof</span> newChild === <span class="string">&#x27;string&#x27;</span> &amp;&amp; newChild !== <span class="string">&#x27;&#x27;</span>) ||</span><br><span class="line">      <span class="keyword">typeof</span> newChild === <span class="string">&#x27;number&#x27;</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      <span class="keyword">return</span> placeSingleChild(</span><br><span class="line">        reconcileSingleTextNode(</span><br><span class="line">          returnFiber,</span><br><span class="line">          currentFirstChild,</span><br><span class="line">          <span class="string">&#x27;&#x27;</span> + newChild,</span><br><span class="line">          lanes,</span><br><span class="line">        ),</span><br><span class="line">      );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining cases are all treated as empty.</span></span><br><span class="line">    <span class="comment">// 如果都匹配不上，则新子节点不存在，标记所有fiber子节点删除</span></span><br><span class="line">    <span class="keyword">return</span> deleteRemainingChildren(returnFiber, currentFirstChild);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reconcileChildFibers;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> reconcileChildFibers = ChildReconciler(<span class="literal">true</span>);</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> mountChildFibers = ChildReconciler(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure>
<h4 id="单节点diff-reconcileSingleElement"><a href="#单节点diff-reconcileSingleElement" class="headerlink" title="单节点diff-reconcileSingleElement"></a>单节点diff-reconcileSingleElement</h4><p>遍历老fiber的子节点，判断是否有可复用的fiber节点</p>
</li>
<li><p>如果key相同，type相同，则复制一个相同的fiber节点，作为当前子节点的fiber，并传入需要更新的props</p>
</li>
<li><p>如果key相同，type不同，则没必要继续比较兄弟节点，将剩余节点都标记为删除，根据ReactElement创建一个新的fiber节点</p>
</li>
<li><p>如果key不同，则将当前老fiber子节点标记为删除，将child指向兄弟节点，继续比较</p>
</li>
<li><p>如果老子fiber节点们的key都与当前子节点的key不同，则创建一个新的fiber节点，并返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileSingleElement</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  element: ReactElement,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> key = element.key;</span><br><span class="line">  <span class="keyword">let</span> child = currentFirstChild;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断是否存在对应子节点</span></span><br><span class="line">  <span class="keyword">while</span> (child !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 1. 比较key是否相同</span></span><br><span class="line">    <span class="keyword">if</span> (child.key === key) &#123;</span><br><span class="line">      <span class="comment">// 如果key相同，则比较type是否相同</span></span><br><span class="line">      <span class="keyword">const</span> elementType = element.type;</span><br><span class="line">      <span class="keyword">if</span> (elementType === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">        <span class="comment">// 如果老fiber子节点和新子节点都是Fragment组件</span></span><br><span class="line">        <span class="keyword">if</span> (child.tag === Fragment) &#123;</span><br><span class="line">          <span class="comment">// 将除当前子节点外的其他兄弟子节点都标记删除</span></span><br><span class="line">          deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">          <span class="comment">// 创建一个克隆fiber，并更新pendingProps为Fragment组件的子节点们</span></span><br><span class="line">          <span class="keyword">const</span> existing = useFiber(child, element.props.children);</span><br><span class="line">          <span class="comment">// 将新fiber指向当前节点</span></span><br><span class="line">          existing.return = returnFiber;</span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          child.elementType === elementType ||</span><br><span class="line">          (<span class="keyword">typeof</span> elementType === <span class="string">&#x27;object&#x27;</span> &amp;&amp;</span><br><span class="line">            elementType !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">            elementType.$$typeof === REACT_LAZY_TYPE &amp;&amp;</span><br><span class="line">            resolveLazy(elementType) === child.type)</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// 如果type相同，将该fiber剩余的兄弟节点都标记为删除</span></span><br><span class="line">          deleteRemainingChildren(returnFiber, child.sibling);</span><br><span class="line">          <span class="comment">// 创建一个克隆fiber，并更新当前ReactElement的新props值</span></span><br><span class="line">          <span class="keyword">const</span> existing = useFiber(child, element.props);</span><br><span class="line">          existing.ref = coerceRef(returnFiber, child, element);</span><br><span class="line">          existing.return = returnFiber;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 返回新fiber</span></span><br><span class="line">          <span class="keyword">return</span> existing;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 如果key相同，但type不同，则没必要继续比较，将包括当前fiber以及兄弟fiber一起标记为删除</span></span><br><span class="line">      deleteRemainingChildren(returnFiber, child);</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果key不相同则将该fiber标记为删除</span></span><br><span class="line">      deleteChild(returnFiber, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前fiber无法复用，开始比较fiber的兄弟节点是否可以复用</span></span><br><span class="line">    child = child.sibling;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (element.type === REACT_FRAGMENT_TYPE) &#123;</span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromFragment(</span><br><span class="line">      element.props.children,</span><br><span class="line">      returnFiber.mode,</span><br><span class="line">      lanes,</span><br><span class="line">      element.key,</span><br><span class="line">    );</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 返回一个根据ReactElement创建的新Fiber</span></span><br><span class="line">    <span class="keyword">const</span> created = createFiberFromElement(element, returnFiber.mode, lanes);</span><br><span class="line">    created.ref = coerceRef(returnFiber, currentFirstChild, element);</span><br><span class="line">    created.return = returnFiber;</span><br><span class="line">    <span class="keyword">return</span> created;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="多节点diff-reconcileChildrenArray"><a href="#多节点diff-reconcileChildrenArray" class="headerlink" title="多节点diff-reconcileChildrenArray"></a>多节点diff-reconcileChildrenArray</h4><p>跟vue的diff不同，因为react是链表形式，不能用双指针形式进行diff，所以react是单指针进行遍历判断<br>第一轮遍历：</p>
</li>
<li><p>如果key不同导致不可复用节点，则跳出第一轮循环</p>
</li>
<li><p>如果key相同，type不同，则创建一个新的fiber，需要将老fiber标记删除</p>
</li>
<li><p>标记最后一个可用fiber的位置</p>
</li>
<li><p>关联新节点的兄弟节点</p>
</li>
<li><p>直到老fiber链表遍历结束或新节点数组遍历结束</p>
</li>
</ul>
<p>在第一遍遍历中，遍历结束的情形有三种：</p>
<ul>
<li>因为key不同，中止遍历</li>
<li>老fiber兄弟链表遍历结束</li>
<li>新子节点数组遍历结束</li>
</ul>
<p>根据三种不同情形进行不同的处理方式</p>
<ul>
<li>如果新子节点数组全部遍历结束，将老fiber链表剩余兄弟节点标记删除</li>
<li>如果老节点链表全部遍历结束，则继续遍历剩余的新节点数组，直接创建一个新fiber节点</li>
<li>如果是因为key不同中止的遍历，则将剩余老fiber链表构建一个map表，通过key值查找对应fiber节点，开启第二轮遍历</li>
</ul>
<p>第二轮遍历：</p>
<ol>
<li>从map中查找是否有可复用的老fiber节点，如果存在则返回复用节点，否则创建一个新节点</li>
<li>根据节点的alternate属性，可判断是否是复用节点，如果是复用节点，则在map中删除对应fiber节点</li>
<li>调用placeChild方法标记节点是否移动<ol>
<li>如果复用节点的位置&lt;此次更新需要插入的位置，则表示该节点需要向右移动，将该fiber标记为插入，此次更新需要插入的位置不变</li>
<li>否则位置不动，将此次更新需要插入的位置执行当前老节点的位置</li>
<li>如果不是复用节点，则标记为插入<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildrenArray</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  returnFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  currentFirstChild: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  newChildren: <span class="built_in">Array</span>&lt;*&gt;,</span></span></span><br><span class="line"><span class="function"><span class="params">  lanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 指向新子fiber链表的第一个子fiber</span></span><br><span class="line">  <span class="keyword">let</span> resultingFirstChild: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 指向最新一个fiber，也就是遍历到当前子节点的fiber</span></span><br><span class="line">  <span class="keyword">let</span> previousNewFiber: Fiber | <span class="literal">null</span> = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> oldFiber = currentFirstChild;</span><br><span class="line">  <span class="keyword">let</span> lastPlacedIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> newIdx = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> nextOldFiber = <span class="literal">null</span>;</span><br><span class="line">  <span class="comment">// 第一轮遍历</span></span><br><span class="line">  <span class="comment">// 结束情况：</span></span><br><span class="line">  <span class="comment">// 1. oldFiber兄弟链表遍历结束</span></span><br><span class="line">  <span class="comment">// 2. newChildren数组遍历结束</span></span><br><span class="line">  <span class="comment">// 3. key不同，中止遍历</span></span><br><span class="line">  <span class="keyword">for</span> (; oldFiber !== <span class="literal">null</span> &amp;&amp; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldFiber.index &gt; newIdx) &#123;</span><br><span class="line">      nextOldFiber = oldFiber;</span><br><span class="line">      oldFiber = <span class="literal">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      nextOldFiber = oldFiber.sibling;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果key不同，返回null</span></span><br><span class="line">    <span class="comment">// 如果key相同，type不同，则返回新创建的fiber</span></span><br><span class="line">    <span class="comment">// 如果key相同，type相同，则返回复用的fiber</span></span><br><span class="line">    <span class="comment">// 如果新节点是文本节点，且key存在，则返回null，否则返回复用节点</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = updateSlot(</span><br><span class="line">      returnFiber,</span><br><span class="line">      oldFiber,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="comment">// 如果key不同，导致不可复用，则跳出第一轮遍历</span></span><br><span class="line">    <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        oldFiber = nextOldFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">      <span class="comment">// 如果update阶段，oldFiber存在，则因为key相同，type不同，导致没有复用上次更新的fiber，则删除上次更新的fiber节点</span></span><br><span class="line">      <span class="keyword">if</span> (oldFiber &amp;&amp; newFiber.alternate === <span class="literal">null</span>) &#123;</span><br><span class="line">        deleteChild(returnFiber, oldFiber);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 标记最后一个可复用节点的位置</span></span><br><span class="line">    lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">    <span class="comment">// 指定新fiber的兄弟指针，建立当前子节点的兄弟链表</span></span><br><span class="line">    <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">      resultingFirstChild = newFiber;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      previousNewFiber.sibling = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    previousNewFiber = newFiber;</span><br><span class="line">    <span class="comment">// 进行下一个兄弟节点的判断</span></span><br><span class="line">    oldFiber = nextOldFiber;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情形一：新子节点数组全部遍历完成</span></span><br><span class="line">  <span class="keyword">if</span> (newIdx === newChildren.length) &#123;</span><br><span class="line">    <span class="comment">// 如果老子节点还有剩余兄弟节点，则说明更新后不存在，剩余子节点标记删除</span></span><br><span class="line">    deleteRemainingChildren(returnFiber, oldFiber);</span><br><span class="line">    <span class="comment">// 直接返回新的第一个子节点</span></span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情形二：老子节点全部遍历完成</span></span><br><span class="line">  <span class="keyword">if</span> (oldFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果新子节点数组还有节点未被处理，则说明是新加入的子节点，则遍历剩余新节点数组，直接创建新节点Fiber</span></span><br><span class="line">    <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">      <span class="keyword">const</span> newFiber = createChild(returnFiber, newChildren[newIdx], lanes);</span><br><span class="line">      <span class="keyword">if</span> (newFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 情形三：老子节点链表未遍历完成，新子节点数组未遍历完成，意味着可能出现位置改变的情况</span></span><br><span class="line">  <span class="comment">// 将剩余的老Fiber节点们组建一个map，key为fiber的key或index，value为fiber</span></span><br><span class="line">  <span class="keyword">const</span> existingChildren = mapRemainingChildren(returnFiber, oldFiber);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 开始第二轮遍历，</span></span><br><span class="line">  <span class="keyword">for</span> (; newIdx &lt; newChildren.length; newIdx++) &#123;</span><br><span class="line">    <span class="comment">// 从map中，判断是否有可复用fiber，如果有返回复用fiber，没有则新创建一个fiber</span></span><br><span class="line">    <span class="keyword">const</span> newFiber = updateFromMap(</span><br><span class="line">      existingChildren,</span><br><span class="line">      returnFiber,</span><br><span class="line">      newIdx,</span><br><span class="line">      newChildren[newIdx],</span><br><span class="line">      lanes,</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">if</span> (newFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">        <span class="comment">// update阶段</span></span><br><span class="line">        <span class="keyword">if</span> (newFiber.alternate !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="comment">// newFiber为复用fiber</span></span><br><span class="line">          <span class="comment">// 在map中删除对应key值</span></span><br><span class="line">          existingChildren.delete(</span><br><span class="line">            newFiber.key === <span class="literal">null</span> ? newIdx : newFiber.key,</span><br><span class="line">          );</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 标记newFiber是否移动</span></span><br><span class="line">      lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);</span><br><span class="line">      <span class="comment">// 串联兄弟链表</span></span><br><span class="line">      <span class="keyword">if</span> (previousNewFiber === <span class="literal">null</span>) &#123;</span><br><span class="line">        resultingFirstChild = newFiber;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        previousNewFiber.sibling = newFiber;</span><br><span class="line">      &#125;</span><br><span class="line">      previousNewFiber = newFiber;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// 如果是update阶段，将剩余老fiber节点标记删除</span></span><br><span class="line">    existingChildren.forEach(<span class="function"><span class="params">child</span> =&gt;</span> deleteChild(returnFiber, child));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> resultingFirstChild;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">placeChild</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  newFiber: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  lastPlacedIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params">  newIndex: number,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">number</span> </span>&#123;</span><br><span class="line">  newFiber.index = newIndex;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    newFiber.flags |= Forked;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> current = newFiber.alternate;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * example:</span></span><br><span class="line"><span class="comment">   * 老： bcd 新： cdb</span></span><br><span class="line"><span class="comment">   * 当指向c，lastPlacedIndex为0，oldIndex为1，oldIndex &gt; lastPlacedIndex，lastPlacedIndex=oldIndex=1</span></span><br><span class="line"><span class="comment">   * 当指向d，lastPlacedIndex为1，oldIndex为2，oldIndex &gt; lastPlacedIndex，lastPlacedIndex=oldIndex=2</span></span><br><span class="line"><span class="comment">   * 当指向b，lastPlacedIndex为2，oldIndex为0，oldIndex &lt; lastPlacedIndex，则标记b为向右移动</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> oldIndex = current.index;</span><br><span class="line">    <span class="keyword">if</span> (oldIndex &lt; lastPlacedIndex) &#123;</span><br><span class="line">      <span class="comment">// 如果该复用节点的位置，小于 这次更新需要插入的位置，则代表该节点需要向右移动</span></span><br><span class="line">      <span class="comment">// This is a move.</span></span><br><span class="line">      newFiber.flags |= Placement;</span><br><span class="line">      <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This item can stay in place.</span></span><br><span class="line">      <span class="comment">// 否则位置不动</span></span><br><span class="line">      <span class="keyword">return</span> oldIndex;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// This is an insertion.</span></span><br><span class="line">    <span class="comment">// 标记为新增</span></span><br><span class="line">    newFiber.flags |= Placement;</span><br><span class="line">    <span class="keyword">return</span> lastPlacedIndex;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="标记删除"><a href="#标记删除" class="headerlink" title="标记删除"></a>标记删除</h4>会将需要删除的节点推进一个deletions数组里，并在父Fiber上标记子节点需要删除<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deleteChild</span>(<span class="params">returnFiber: Fiber, childToDelete: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!shouldTrackSideEffects) &#123;</span><br><span class="line">    <span class="comment">// Noop.</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> deletions = returnFiber.deletions;</span><br><span class="line">  <span class="keyword">if</span> (deletions === <span class="literal">null</span>) &#123;</span><br><span class="line">    returnFiber.deletions = [childToDelete];</span><br><span class="line">    returnFiber.flags |= ChildDeletion;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    deletions.push(childToDelete);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="“归”-CompleteWork"><a href="#“归”-CompleteWork" class="headerlink" title="“归”-CompleteWork"></a>“归”-CompleteWork</h2>在completeUnitOfWork中，主要循环执行fiber树的向上遍历，如果存在兄弟节点，则返回performUnitOfWork中，进行beginWork，直到向下遍历到叶子节点，再执行completeUnitOfWork，直至遍历到根节点为止<br>在mount阶段，completeWork主要是做离屏DOM树的创建，由下往上进行挂载<br>在update阶段，则记录需要更新的props<br>以及向上做属性冒泡处理，将节点的flags向上冒泡到父节点的subtreeFlags中，表示该节点下的子节点存在哪些更新，方便在commit阶段，向下判断处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeUnitOfWork</span>(<span class="params">unitOfWork: Fiber</span>): <span class="title">void</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这次更新创建的fiber</span></span><br><span class="line">  <span class="keyword">let</span> completedWork = unitOfWork;</span><br><span class="line">  <span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="comment">// 当前fiber，也就是上次更新创建的fiber</span></span><br><span class="line">    <span class="keyword">const</span> current = completedWork.alternate;</span><br><span class="line">    <span class="comment">// 父fiber</span></span><br><span class="line">    <span class="keyword">const</span> returnFiber = completedWork.return;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 检查当前fiber是否已经标记已经完成处理</span></span><br><span class="line">    <span class="keyword">if</span> ((completedWork.flags &amp; Incomplete) === NoFlags) &#123;</span><br><span class="line">      <span class="keyword">let</span> next;</span><br><span class="line">      next = completeWork(current, completedWork, subtreeRenderLanes);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 如果派生出其他子节点，则返回beginWork进行处理</span></span><br><span class="line">      <span class="keyword">if</span> (next !== <span class="literal">null</span>) &#123;</span><br><span class="line">        workInProgress = next;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 异常处理...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> siblingFiber = completedWork.sibling;</span><br><span class="line">    <span class="keyword">if</span> (siblingFiber !== <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 如果当前fiber有兄弟节点，则将兄弟节点作为当前执行fiber，返回执行beginWork</span></span><br><span class="line">      workInProgress = siblingFiber;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 否则将父fiber作为completedWork，继续对父fiber做completeWork处理</span></span><br><span class="line">    completedWork = returnFiber;</span><br><span class="line">    workInProgress = completedWork;</span><br><span class="line">  &#125; <span class="keyword">while</span> (completedWork !== <span class="literal">null</span>); </span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 直到遍历到RootFiber，退出遍历</span></span><br><span class="line">  <span class="keyword">if</span> (workInProgressRootExitStatus === RootInProgress) &#123;</span><br><span class="line">    workInProgressRootExitStatus = RootCompleted;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
如果是原生组件：</li>
</ol>
</li>
</ol>
<ul>
<li>update阶段<ul>
<li>将需要更新的props以数组的形式存放在fiber的updateQueue属性上，并标记需要更新</li>
<li>如果ref不同，则标记ref存在更新</li>
</ul>
</li>
<li>mount阶段<ul>
<li>如果没有需要更新的props值，则直接做属性冒泡处理，并直接返回</li>
<li>为fiber创建一个DOM节点</li>
<li>如果有子fiber，则将子fiber以及子fiber的兄弟fiber的stateNode，都挂载到当前DOM节点下</li>
<li>将当前fiber节点的stateNode指向DOM节点，并处理一些props的初始化</li>
<li>如果ref存在，则标记ref更新</li>
<li>并做属性冒泡处理<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">completeWork</span>(<span class="params"></span></span></span><br><span class="line"><span class="function"><span class="params">  current: Fiber | <span class="literal">null</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">  workInProgress: Fiber,</span></span></span><br><span class="line"><span class="function"><span class="params">  renderLanes: Lanes,</span></span></span><br><span class="line"><span class="function"><span class="params"></span>): <span class="title">Fiber</span> | <span class="title">null</span> </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;进入了completeWork&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> newProps = workInProgress.pendingProps;</span><br><span class="line"></span><br><span class="line">  popTreeContext(workInProgress);</span><br><span class="line">  <span class="keyword">switch</span> (workInProgress.tag) &#123;</span><br><span class="line">    <span class="keyword">case</span> IndeterminateComponent:</span><br><span class="line">    <span class="keyword">case</span> FunctionComponent:</span><br><span class="line">      <span class="comment">// 属性冒泡</span></span><br><span class="line">      <span class="comment">// 1. 将子孙fiber的lanes冒泡到当前fiber的lanes中</span></span><br><span class="line"> 			<span class="comment">// 2. 将子孙fiber的改动标记冒泡到当前fiber的subtreeFlags上</span></span><br><span class="line"> 			<span class="comment">// 3. 将所有子fiber的return指向自己</span></span><br><span class="line">      <span class="comment">// 4. 返回当前fiber是否复用</span></span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">case</span> ClassComponent: &#123;</span><br><span class="line">      <span class="keyword">const</span> Component = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (isLegacyContextProvider(Component)) &#123;</span><br><span class="line">        popLegacyContext(workInProgress);</span><br><span class="line">      &#125;</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostRoot: &#123;</span><br><span class="line">      <span class="keyword">const</span> fiberRoot = (workInProgress.stateNode: FiberRoot);</span><br><span class="line">      </span><br><span class="line">      popRootTransition(workInProgress, fiberRoot, renderLanes);</span><br><span class="line">      popHostContainer(workInProgress);</span><br><span class="line">      popTopLevelLegacyContextObject(workInProgress);</span><br><span class="line">      resetMutableSourceWorkInProgressVersions();</span><br><span class="line">      <span class="keyword">if</span> (fiberRoot.pendingContext) &#123;</span><br><span class="line">        fiberRoot.context = fiberRoot.pendingContext;</span><br><span class="line">        fiberRoot.pendingContext = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (current === <span class="literal">null</span> || current.child === <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current !== <span class="literal">null</span>) &#123;</span><br><span class="line">          <span class="keyword">const</span> prevState: RootState = current.memoizedState;</span><br><span class="line">          <span class="keyword">if</span> (</span><br><span class="line">            (workInProgress.flags &amp; ForceClientRender) !== NoFlags</span><br><span class="line">          ) &#123;</span><br><span class="line">            workInProgress.flags |= Snapshot;</span><br><span class="line">            upgradeHydrationErrorsToRecoverable();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostComponent: &#123;</span><br><span class="line">      popHostContext(workInProgress);</span><br><span class="line">      <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">      <span class="keyword">const</span> type = workInProgress.type;</span><br><span class="line">      <span class="keyword">if</span> (current !== <span class="literal">null</span> &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// update阶段且是复用原有fiber节点，已存在DOM节点</span></span><br><span class="line">        <span class="comment">// 1. 将需要更新的props以数组的形式存放在fiber的updateQueue上</span></span><br><span class="line">        <span class="comment">//    ex: [propKey1, propValue1, propsKey2, propsValue2...]</span></span><br><span class="line">        <span class="comment">// 2. 如果存在需要更新的props，则将fiber.flags标记需要更新</span></span><br><span class="line">        updateHostComponent(</span><br><span class="line">          current,</span><br><span class="line">          workInProgress,</span><br><span class="line">          type,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (current.ref !== workInProgress.ref) &#123;</span><br><span class="line">          <span class="comment">// 如果当前fiber与上次更新的fiber的ref不同，则在flags标记ref更新</span></span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// mount阶段 或 update阶段，没有复用fiber节点，新创建的fiber节点，也就是没有对应的DOM节点</span></span><br><span class="line">        <span class="keyword">if</span> (!newProps) &#123;</span><br><span class="line">          <span class="keyword">if</span> (workInProgress.stateNode === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">&#x27;We must have new props for new mounts. This error is likely &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          bubbleProperties(workInProgress);</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line">        <span class="comment">// 为fiber节点创建对应的DOM节点</span></span><br><span class="line">        <span class="keyword">const</span> instance = createInstance(</span><br><span class="line">          type,</span><br><span class="line">          newProps,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">          currentHostContext,</span><br><span class="line">          workInProgress,</span><br><span class="line">        );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果有子fiber，则将子fiber以及子fiber的兄弟fiber的stateNode，都挂载到当前DOM节点下</span></span><br><span class="line">        appendAllChildren(instance, workInProgress, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前fiber节点的stateNode指向DOM节点</span></span><br><span class="line">        workInProgress.stateNode = instance;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理初始化props（事件的相关处理）</span></span><br><span class="line">        <span class="keyword">if</span> (</span><br><span class="line">          finalizeInitialChildren(</span><br><span class="line">            instance,</span><br><span class="line">            type,</span><br><span class="line">            newProps,</span><br><span class="line">            rootContainerInstance,</span><br><span class="line">            currentHostContext,</span><br><span class="line">          )</span><br><span class="line">        ) &#123;</span><br><span class="line">          <span class="comment">// 处理focus，如果props有autoFocus，则需要标记更新</span></span><br><span class="line">          markUpdate(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (workInProgress.ref !== <span class="literal">null</span>) &#123;</span><br><span class="line">          markRef(workInProgress);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> HostText: &#123;</span><br><span class="line">      <span class="keyword">const</span> newText = newProps;</span><br><span class="line">      <span class="keyword">if</span> (current &amp;&amp; workInProgress.stateNode != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> oldText = current.memoizedProps;</span><br><span class="line">        <span class="comment">// 如果文本不同，则标记更新</span></span><br><span class="line">        updateHostText(current, workInProgress, oldText, newText);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> newText !== <span class="string">&#x27;string&#x27;</span>) &#123;</span><br><span class="line">          <span class="keyword">if</span> (workInProgress.stateNode === <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">              <span class="string">&#x27;We must have new props for new mounts. This error is likely &#x27;</span> +</span><br><span class="line">                <span class="string">&#x27;caused by a bug in React. Please file an issue.&#x27;</span>,</span><br><span class="line">            );</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// This can happen when we abort work.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> rootContainerInstance = getRootHostContainer();</span><br><span class="line">        <span class="keyword">const</span> currentHostContext = getHostContext();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 创建一个文本DOM节点</span></span><br><span class="line">        workInProgress.stateNode = createTextInstance(</span><br><span class="line">          newText,</span><br><span class="line">          rootContainerInstance,</span><br><span class="line">          currentHostContext,</span><br><span class="line">          workInProgress,</span><br><span class="line">        );</span><br><span class="line">        </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 属性冒泡</span></span><br><span class="line">      bubbleProperties(workInProgress);</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 省略了其他类型</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/js/" rel="tag"># js</a>
              <a href="/tags/react/" rel="tag"># react</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2023/02/22/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%88%9D%E6%AC%A1%E5%88%9B%E5%BB%BA%E6%B8%B2%E6%9F%93/" rel="prev" title="React源码阅读笔记-初次创建渲染">
      <i class="fa fa-chevron-left"></i> React源码阅读笔记-初次创建渲染
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/03/14/React%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-commit%E9%98%B6%E6%AE%B5/" rel="next" title="React源码阅读笔记-commit阶段">
      React源码阅读笔记-commit阶段 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%A5%E5%8F%A3%E5%87%BD%E6%95%B0"><span class="nav-number">1.</span> <span class="nav-text">入口函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9C%E9%80%92%E2%80%9D-beginWork"><span class="nav-number">2.</span> <span class="nav-text">“递”-beginWork</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E6%A0%B9%E8%8A%82%E7%82%B9-HostRoot"><span class="nav-number">2.1.</span> <span class="nav-text">原生根节点-HostRoot</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8D%E6%98%8E%E7%A1%AE%E7%BB%84%E4%BB%B6-IndeterminateComponent"><span class="nav-number">2.2.</span> <span class="nav-text">不明确组件-IndeterminateComponent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8E%9F%E7%94%9F%E7%BB%84%E4%BB%B6-HostComponent"><span class="nav-number">2.3.</span> <span class="nav-text">原生组件-HostComponent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%BD%E6%95%B0%E7%BB%84%E4%BB%B6-FunctionComponent"><span class="nav-number">2.4.</span> <span class="nav-text">函数组件-FunctionComponent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%BB%84%E4%BB%B6-ClassComponent"><span class="nav-number">2.5.</span> <span class="nav-text">类组件-ClassComponent</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A0%B8%E5%BF%83%E5%87%BD%E6%95%B0%EF%BC%9AreconcileChildren%EF%BC%88diff%E7%AE%97%E6%B3%95%EF%BC%89"><span class="nav-number">2.6.</span> <span class="nav-text">核心函数：reconcileChildren（diff算法）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8D%95%E8%8A%82%E7%82%B9diff-reconcileSingleElement"><span class="nav-number">2.6.1.</span> <span class="nav-text">单节点diff-reconcileSingleElement</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%9A%E8%8A%82%E7%82%B9diff-reconcileChildrenArray"><span class="nav-number">2.6.2.</span> <span class="nav-text">多节点diff-reconcileChildrenArray</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A0%87%E8%AE%B0%E5%88%A0%E9%99%A4"><span class="nav-number">2.6.3.</span> <span class="nav-text">标记删除</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E2%80%9C%E5%BD%92%E2%80%9D-CompleteWork"><span class="nav-number">3.</span> <span class="nav-text">“归”-CompleteWork</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="赵依婷"
      src="/uploads/avatar.jpeg">
  <p class="site-author-name" itemprop="name">赵依婷</p>
  <div class="site-description" itemprop="description">打工都是人上人！</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">23</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">16</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/xzhao95" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;xzhao95" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="mailto:zhaoyiting26@163.com" title="E-Mail → mailto:zhaoyiting26@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i></a>
      </span>
      <span class="links-of-author-item">
        <a href="https://weibo.com/u/3295465524" title="Weibo → https:&#x2F;&#x2F;weibo.com&#x2F;u&#x2F;3295465524" rel="noopener" target="_blank"><i class="fab fa-weibo fa-fw"></i></a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">赵依婷</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="https://code.jquery.com/jquery-3.4.1.min.js"></script>
  <script src="//cdn.jsdelivr.net/gh/fancyapps/fancybox@3/dist/jquery.fancybox.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/valine@1.4.14/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'GbmucVnm0BdUOjFle71Gu7sb-gzGzoHsz',
      appKey     : 'XShaIHR81BPhKR7DtM27n5Qh',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : false,
      lang       : '' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

  

  <script src="/js/wobblewindow.js"></script>
  <script>
    //只在桌面版网页启用特效
    if( window.innerWidth > 768  ){
      $(document).ready(function () {
        
          $('.header').wobbleWindow({
            radius: 50,
            movementTop: false,
            movementLeft: false,
            movementRight: false,
            debug: false,
          });
        

        

        
      });
    }
  </script>

</body>
</html>
